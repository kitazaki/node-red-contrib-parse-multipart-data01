[{"id":"d673a22601473fac","type":"subflow","name":"parse-multipart-data","info":"","category":"","in":[{"x":60,"y":80,"wires":[{"id":"3c7dc1bb68b0345c"}]}],"out":[{"x":340,"y":80,"wires":[{"id":"3c7dc1bb68b0345c","port":0}]}],"env":[],"meta":{"module":"node-red-contrib-parse-multipart-data01","type":"parse-multipart-data","version":"v0.0.2","author":"Ayachika Kitazaki <kitazaki@gmail.com>","desc":"A node to parse multipart data module","keywords":"node-red,parse-multipart-data","license":"Apache-2.0"},"color":"#DDAA99"},{"id":"3c7dc1bb68b0345c","type":"function","z":"d673a22601473fac","name":"function 2","func":"function getBoundary(header){\n\tif (typeof header === 'undefined' || header === null) {\n        return \"\";\n    }\n\tvar items = header.split(';');\n\tif(items)\n\t\tfor(let i=0;i<items.length;i++){\n\t\t\tvar item = (new String(items[i])).trim();\n\t\t\tif(item.indexOf('boundary') >= 0){\n\t\t\t\tvar k = item.split('=');\n\t\t\t\treturn (new String(k[1])).trim();\n\t\t\t}\n\t\t}\n\treturn \"\";\n}\n\nfunction obj(str){\n\tif (typeof str === 'undefined' || str === null) {\n        return {};\n    }\n\tvar k = str.split('=');\n\tif (k.length < 2) { // '='で分割した結果が2つの要素を持たない場合\n        return {}; // または適切なエラーハンドリング\n    }\n\tvar a = k[0].trim();\n\tvar b = JSON.parse(k[1].trim());\n\tvar o = {};\n\tObject.defineProperty( o , a , \n\t\t{ value: b, writable: true, enumerable: true, configurable: true })\n\treturn o;\n}\n\nfunction process1(part){\n\tif (typeof part.header === 'undefined' || part.header === null) {\n       \treturn {};\n    }\n\tvar header = part.header.split(';');\n\tvar file = obj(header.length > 2 ? header[2] : null); // header[2]が存在しない場合はnullを渡す\n    if (typeof part.info === 'undefined' || part.info === null || !part.info.includes(':')) {\n       \treturn file; // part.infoが不正な形式の場合はfileをそのまま返す\n    }\n    var contentTypeParts = part.info.split(':');\n    if (contentTypeParts.length < 2) {\n       \treturn file; // ':'で分割した結果が2つの要素を持たない場合\n    }\t\t\n\tvar file = obj(header[2]);\n\tvar contentType = part.info.split(':')[1].trim();\t\t\n\tObject.defineProperty( file , 'type' , \n\t\t{ value: contentType, writable: true, enumerable: true, configurable: true })\n\tObject.defineProperty( file , 'data' , \n\t\t{ value: new Buffer(part.part), writable: true, enumerable: true, configurable: true })\n\treturn file;\n}\n\nfunction Parse(multipartBodyBuffer,boundary){\n\tvar prev = null;\n\tvar lastline='';\n\tvar header = '';\n\tvar info = ''; var state=0; var buffer=[];\n\tvar allParts = [];\n\n\tfor(let i=0;i<multipartBodyBuffer.length;i++){\n\t\tvar oneByte = multipartBodyBuffer[i];\n\t\tvar prevByte = i > 0 ? multipartBodyBuffer[i-1] : null;\n\t\tvar newLineDetected = ((oneByte == 0x0a) && (prevByte == 0x0d)) ? true : false;\n\t\tvar newLineChar = ((oneByte == 0x0a) || (oneByte == 0x0d)) ? true : false;\n\n\t\tif(!newLineChar)\n\t\t\tlastline += String.fromCharCode(oneByte);\n\n\t\tif((0 == state) && newLineDetected){\n\t\t\tif((\"--\"+boundary) == lastline){\n\t\t\t\tstate=1;\n\t\t\t}\n\t\t\tlastline='';\n\t\t}else\n\t\tif((1 == state) && newLineDetected){\n\t\t\theader = lastline;\n\t\t\tstate=2;\n\t\t\tlastline='';\n\t\t}else\n\t\tif((2 == state) && newLineDetected){\n\t\t\tinfo = lastline;\n\t\t\tstate=3;\n\t\t\tlastline='';\n\t\t}else\n\t\tif((3 == state) && newLineDetected){\n\t\t\tstate=4;\n\t\t\tbuffer=[];\n\t\t\tlastline='';\n\t\t}else\n\t\tif(4 == state){\n\t\t\tif(lastline.length > (boundary.length+4)) lastline=''; // mem save\n\t\t\tif((((\"--\"+boundary) == lastline))){\n\t\t\t\tvar j = buffer.length - lastline.length;\n\t\t\t\tvar part = buffer.slice(0,j-1);\n\t\t\t\tvar p = { header : header , info : info , part : part  };\n\t\t\t\tallParts.push(process1(p));\n\t\t\t\tbuffer = []; lastline=''; state=5; header=''; info='';\n\t\t\t}else{\n\t\t\t\tbuffer.push(oneByte);\n\t\t\t}\n\t\t\tif(newLineDetected) lastline='';\n\t\t}else\n\t\tif(5==state){\n\t\t\tif(newLineDetected)\n\t\t\t\tstate=1;\n\t\t}\n\t}\n\treturn allParts;\n};\n\nconst body = msg.payload;\nconst lines = body.toString().split('\\r\\n');\nconst boundary = lines[0].slice(2);\n\nconst parts = Parse(body, boundary);\n\n//msg.payload = parts;\nmsg.payload = parts[0].data;\n\nreturn msg;\n","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":200,"y":80,"wires":[[]]},{"id":"d687bfa7bccfbbf1","type":"subflow:d673a22601473fac","z":"e459b0abf68836a4","name":"","x":380,"y":280,"wires":[["5517872cf2d90f7e","179a562833834d67"]]}]